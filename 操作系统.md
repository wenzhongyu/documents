# 操作系统

## 进程间五种通信方式的比较

1. 管道：速度慢，容量有限，只有父子进程能通讯。
2. FIFO：任何进程间都能通讯，但速度慢。
3. 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
4. 信号量：不能传递复杂消息，只能用来同步。
5. 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。

## 进程间如何通信，线程间如何切换

1. 进程通信：管道、命名管道、消息队列、内存、网络。 
2. 线程切换：底层CPU时间片的概念。可以引入并发控制的一些概念，两种锁，信号量等等。

## 零拷贝

1. RocketMQ的消息采用`顺序写`到commitlog文件，然后利用`consume queue文件`作为索引；

2. RocketMQ采用`零拷贝 mmap + write`的方式来回应Consumer的请求； 
3. 同样kafka中存在大量的网络数据持久化到磁盘和磁盘文件通过网络发送的过程，kafka使用了`sendfile零拷贝`方式

## BIO、AIO、NIO分别是什么，有什么区别？

BIO：同步阻塞，会阻塞两次：1.获取连接时accept()； 2.read()数据时 bio要处理多个请求，则每个请求都需要开启一个线程去处理请求，如果大部分请求只是连接不发送数据会造成资源的浪费，那么我们就去考虑能否通过一个线程去轮询来处理多个请求 

NIO：同步非阻塞，将多个客户端的请求都注册到selector选择器上，每个请求对应一个channel通道来发送数据和接收数据(防止客户端多次请求服务端丢失对应的关系)，所以服务端需要从selector去轮询也就是遍历channel通道将有数据的请求交给工作线程来处理，即读取channel获取请求体，写channel来响应，不过轮询遍历过程是交给操作系统来完成的

1. BIO：同步阻塞，服务端会阻塞两次accpet()和read()时，这样导致BIO在并发只能一个请求服务端单独去开启一个连接来处理请求；

   BIO优化方式：通过线程池管理线程，不需要每次都创建和销毁能力合理的控制并发量；

2. NIO：同步非阻塞，NIO下每个请求都需要开启一个线程，所以想着是否能让两次阻塞都变成非阻塞，所以在BIO下提供了serverSocketChannel.configureBlocking(false)和socketChannel.configureBlocking(false)方法，让线程变成未阻塞状态，即一个线程可以处理多个请求，中间包括了selector多路复用选择器

   channel：通道用来传输数据，可以比喻做工厂传输纽带 

   bytebuffer：缓冲区数据，比如为工厂中箱子放在纽带中传输；

   为了保证客户端和服务端之间的连接时对应的，为每个客户端创建一个新的channel通道，所有的channel通过放入到一个list中交给操作系统来轮询对应select poll epoll，大概就是拷贝用户态的数据到内核态或者两个区域之间共享。

   

 网络数据的读取分为两个阶段，第一个阶段是从网卡读到内核，第二个阶段是从内核缓存读到用户空间。

 网络模型： 

1. 同步阻塞IO：在最开始发送一个读取请求的系统调用，OS完成以上两个操作以后响应对应的数据，在这段时间该线程啥都不能做。

2. 同步非阻塞IO：针对于同步阻塞，它在第一个阶段的时间内，采用轮询的方式确认OS内核数据是否准备好，准备好了之后再进行系统读取调用。 

3. 多路复用：就是将轮询变成了一个select。对应linux中的是select/poll/epoll。 

4. 信号量驱动：上面的select变成了一个信号量。 

5. 异步IO：以上两个阶段全部由OS去做，完成后主动回调应用接口。控制反转。 

优劣分析： 

BIO：基于这种模型下的网络通信，一个请求就需要一个线程，因此不能承受大量客户端。 优化后的BIO，也是同样的网络模型，不过用线程池来作为了一个缓冲，但是问题依旧是每个请求都需要一个线程去处理，而且资源受限。一旦某些请求卡死，则线程池中线程无法释放会出现问题。 

NIO：NIO其实有两个概念，一个是上面的多路复用模型称之为 no-block IO，还有一个是java里面的New IO库，一般都讲后面那个基于前面那个模型去实现的。对应的主要组件有selecter/buffer/channel。优点是可以通过多路复用模型管理大量的连接，缺点在于编程的复杂度以及java库本身的bug，所以才有了netty这个框架对New IO库进一步的封装优化。

## 死锁的4个必要条件

1. 互斥条件：一个资源每次只能被一个线程使用；
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；
3. 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 